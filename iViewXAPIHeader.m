function [fcns,structs,enuminfo,ThunkLibName]=iViewXAPIHeader
%IVIEWXAPIHEADER Create structures to define interfaces found in 'iViewXAPI'.

% DN fixes:
% 1. image struct needs data member declared as uint8, not char
% 2. comment out callbacks, these are not supported by matlab and lead to
%    errors upon loading
% 3. added missing enums RecordingState and TrackingMode
% 4. added 64bit mode (merged from separate file)
% 5. set things that are the same for all functions at once instead of
%    individually
% 6. copied (and slightly fixed) documentation from iViewXAPI.h, for the
%    enums and data structures

q64Bit = strcmp(computer('arch'), 'win64');


%This function was generated by loadlibrary.m parser version 1.1.6.36 on Thu Jun  4 14:38:14 2015
%perl options:'iViewXAPI.i -outfile=iViewXAPIHeader.m'
ival={cell(1,105)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);
if q64Bit
    fcns.thunkname = ival{1};
end
% extern " C " int iV_AbortCalibration (); 
fcns.name{fcnNum}='iV_AbortCalibration'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_AbortCalibrationPoint (); 
fcns.name{fcnNum}='iV_AbortCalibrationPoint'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_AcceptCalibrationPoint (); 
fcns.name{fcnNum}='iV_AcceptCalibrationPoint'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_Calibrate (); 
fcns.name{fcnNum}='iV_Calibrate'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ChangeCalibrationPoint ( int number , int positionX , int positionY ); 
fcns.name{fcnNum}='iV_ChangeCalibrationPoint'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ClearAOI (); 
fcns.name{fcnNum}='iV_ClearAOI'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ClearRecordingBuffer (); 
fcns.name{fcnNum}='iV_ClearRecordingBuffer'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ConfigureFilter ( enum FilterType filter , enum FilterAction action , void * data ); 
fcns.name{fcnNum}='iV_ConfigureFilter'; fcns.RHS{fcnNum}={'FilterType', 'FilterAction', 'voidPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32enumFilterTypeenumFilterActionvoidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_Connect ( char * sendIPAddress , int sendPort , char * recvIPAddress , int receivePort ); 
fcns.name{fcnNum}='iV_Connect'; fcns.RHS{fcnNum}={'cstring', 'int32', 'cstring', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringint32cstringint32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ConnectLocal (); 
fcns.name{fcnNum}='iV_ConnectLocal'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ContinueEyetracking (); 
fcns.name{fcnNum}='iV_ContinueEyetracking'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ContinueRecording ( char * etMessage ); 
fcns.name{fcnNum}='iV_ContinueRecording'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DefineAOI ( struct AOIStruct * aoiData ); 
fcns.name{fcnNum}='iV_DefineAOI'; fcns.RHS{fcnNum}={'AOIStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DefineAOIPort ( int port ); 
fcns.name{fcnNum}='iV_DefineAOIPort'; fcns.RHS{fcnNum}={'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DeleteREDGeometry ( char * setupName ); 
fcns.name{fcnNum}='iV_DeleteREDGeometry'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DisableAOI ( char * aoiName ); 
fcns.name{fcnNum}='iV_DisableAOI'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DisableAOIGroup ( char * aoiGroup ); 
fcns.name{fcnNum}='iV_DisableAOIGroup'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DisableGazeDataFilter (); 
fcns.name{fcnNum}='iV_DisableGazeDataFilter'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DisableProcessorHighPerformanceMode (); 
fcns.name{fcnNum}='iV_DisableProcessorHighPerformanceMode'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_Disconnect (); 
fcns.name{fcnNum}='iV_Disconnect'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_EnableAOI ( char * aoiName ); 
fcns.name{fcnNum}='iV_EnableAOI'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_EnableAOIGroup ( char * aoiGroup ); 
fcns.name{fcnNum}='iV_EnableAOIGroup'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_EnableGazeDataFilter (); 
fcns.name{fcnNum}='iV_EnableGazeDataFilter'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_EnableProcessorHighPerformanceMode (); 
fcns.name{fcnNum}='iV_EnableProcessorHighPerformanceMode'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetAccuracy ( struct AccuracyStruct * accuracyData , int visualization ); 
fcns.name{fcnNum}='iV_GetAccuracy'; fcns.RHS{fcnNum}={'AccuracyStructPtr', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrint32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetAccuracyImage ( struct ImageStruct * imageData ); 
fcns.name{fcnNum}='iV_GetAccuracyImage'; fcns.RHS{fcnNum}={'ImageStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetAOIOutputValue ( int * aoiOutputValue ); 
fcns.name{fcnNum}='iV_GetAOIOutputValue'; fcns.RHS{fcnNum}={'int32Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetAvailableLptPorts ( char * buffer , int * bufferSize ); 
fcns.name{fcnNum}='iV_GetAvailableLptPorts'; fcns.RHS{fcnNum}={'cstring', 'int32Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringvoidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCalibrationParameter ( struct CalibrationStruct * calibrationData ); 
fcns.name{fcnNum}='iV_GetCalibrationParameter'; fcns.RHS{fcnNum}={'CalibrationStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCalibrationPoint ( int calibrationPointNumber , struct CalibrationPointStruct * calibrationPoint ); 
fcns.name{fcnNum}='iV_GetCalibrationPoint'; fcns.RHS{fcnNum}={'int32', 'CalibrationPointStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCalibrationQuality ( int calibrationPointNumber , struct CalibrationPointQualityStruct * left , struct CalibrationPointQualityStruct * right ); 
fcns.name{fcnNum}='iV_GetCalibrationQuality'; fcns.RHS{fcnNum}={'int32', 'CalibrationPointQualityStructPtr', 'CalibrationPointQualityStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32voidPtrvoidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCalibrationQualityImage ( struct ImageStruct * imageData ); 
fcns.name{fcnNum}='iV_GetCalibrationQualityImage'; fcns.RHS{fcnNum}={'ImageStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCalibrationStatus ( enum CalibrationStatusEnum * calibrationStatus ); 
fcns.name{fcnNum}='iV_GetCalibrationStatus'; fcns.RHS{fcnNum}={'CalibrationStatusEnumPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCurrentCalibrationPoint ( struct CalibrationPointStruct * currentCalibrationPoint ); 
fcns.name{fcnNum}='iV_GetCurrentCalibrationPoint'; fcns.RHS{fcnNum}={'CalibrationPointStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCurrentREDGeometry ( struct REDGeometryStruct * redGeometry ); 
fcns.name{fcnNum}='iV_GetCurrentREDGeometry'; fcns.RHS{fcnNum}={'REDGeometryStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetCurrentTimestamp ( long long * currentTimestamp ); 
fcns.name{fcnNum}='iV_GetCurrentTimestamp'; fcns.RHS{fcnNum}={'int64Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetDeviceName ( char deviceName [ 64 ]); 
fcns.name{fcnNum}='iV_GetDeviceName'; fcns.RHS{fcnNum}={'int8Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetEvent ( struct EventStruct * eventDataSample ); 
fcns.name{fcnNum}='iV_GetEvent'; fcns.RHS{fcnNum}={'EventStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetEvent32 ( struct EventStruct32 * eventDataSample ); 
fcns.name{fcnNum}='iV_GetEvent32'; fcns.RHS{fcnNum}={'EventStruct32Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetEyeImage ( struct ImageStruct * imageData ); 
fcns.name{fcnNum}='iV_GetEyeImage'; fcns.RHS{fcnNum}={'ImageStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetFeatureKey ( long long * featureKey ); 
fcns.name{fcnNum}='iV_GetFeatureKey'; fcns.RHS{fcnNum}={'int64Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetGazeChannelQuality ( struct GazeChannelQualityStruct * qualityData ); 
fcns.name{fcnNum}='iV_GetGazeChannelQuality'; fcns.RHS{fcnNum}={'GazeChannelQualityStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetGeometryProfiles ( int maxSize , char * profileNames ); 
fcns.name{fcnNum}='iV_GetGeometryProfiles'; fcns.RHS{fcnNum}={'int32', 'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetLicenseDueDate ( struct DateStruct * licenseDueDate ); 
fcns.name{fcnNum}='iV_GetLicenseDueDate'; fcns.RHS{fcnNum}={'DateStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetRecordingState ( enum RecordingState * recordingState ); 
fcns.name{fcnNum}='iV_GetRecordingState'; fcns.RHS{fcnNum}={'RecordingStatePtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetREDGeometry ( char * profileName , struct REDGeometryStruct * redGeometry ); 
fcns.name{fcnNum}='iV_GetREDGeometry'; fcns.RHS{fcnNum}={'cstring', 'REDGeometryStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringvoidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetSample ( struct SampleStruct * rawDataSample ); 
fcns.name{fcnNum}='iV_GetSample'; fcns.RHS{fcnNum}={'SampleStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetSample32 ( struct SampleStruct32 * rawDataSample ); 
fcns.name{fcnNum}='iV_GetSample32'; fcns.RHS{fcnNum}={'SampleStruct32Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetSceneVideo ( struct ImageStruct * imageData ); 
fcns.name{fcnNum}='iV_GetSceneVideo'; fcns.RHS{fcnNum}={'ImageStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetSerialNumber ( char serialNumber [ 64 ]); 
fcns.name{fcnNum}='iV_GetSerialNumber'; fcns.RHS{fcnNum}={'int8Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetSpeedModes ( struct SpeedModeStruct * speedModes ); 
fcns.name{fcnNum}='iV_GetSpeedModes'; fcns.RHS{fcnNum}={'SpeedModeStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetSystemInfo ( struct SystemInfoStruct * systemInfoData ); 
fcns.name{fcnNum}='iV_GetSystemInfo'; fcns.RHS{fcnNum}={'SystemInfoStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetTrackingMonitor ( struct ImageStruct * imageData ); 
fcns.name{fcnNum}='iV_GetTrackingMonitor'; fcns.RHS{fcnNum}={'ImageStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetTrackingMode ( enum TrackingMode * mode ); 
fcns.name{fcnNum}='iV_GetTrackingMode'; fcns.RHS{fcnNum}={'TrackingModePtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetTrackingStatus ( struct TrackingStatusStruct * trackingStatus ); 
fcns.name{fcnNum}='iV_GetTrackingStatus'; fcns.RHS{fcnNum}={'TrackingStatusStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetUseCalibrationKeys ( int * enableKeys ); 
fcns.name{fcnNum}='iV_GetUseCalibrationKeys'; fcns.RHS{fcnNum}={'int32Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_HideAccuracyMonitor (); 
fcns.name{fcnNum}='iV_HideAccuracyMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_HideEyeImageMonitor (); 
fcns.name{fcnNum}='iV_HideEyeImageMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_HideSceneVideoMonitor (); 
fcns.name{fcnNum}='iV_HideSceneVideoMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_HideTrackingMonitor (); 
fcns.name{fcnNum}='iV_HideTrackingMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_IsConnected (); 
fcns.name{fcnNum}='iV_IsConnected'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_LoadCalibration ( char * name ); 
fcns.name{fcnNum}='iV_LoadCalibration'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_Log ( char * logMessage ); 
fcns.name{fcnNum}='iV_Log'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_PauseEyetracking (); 
fcns.name{fcnNum}='iV_PauseEyetracking'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_PauseRecording (); 
fcns.name{fcnNum}='iV_PauseRecording'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_Quit (); 
fcns.name{fcnNum}='iV_Quit'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_RecalibrateOnePoint ( int number ); 
fcns.name{fcnNum}='iV_RecalibrateOnePoint'; fcns.RHS{fcnNum}={'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ReleaseAOIPort (); 
fcns.name{fcnNum}='iV_ReleaseAOIPort'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_RemoveAOI ( char * aoiName ); 
fcns.name{fcnNum}='iV_RemoveAOI'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ResetCalibrationPoints (); 
fcns.name{fcnNum}='iV_ResetCalibrationPoints'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SaveCalibration ( char * name ); 
fcns.name{fcnNum}='iV_SaveCalibration'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SaveData ( char * filename , char * description , char * user , int overwrite ); 
fcns.name{fcnNum}='iV_SaveData'; fcns.RHS{fcnNum}={'cstring', 'cstring', 'cstring', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringcstringcstringint32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SelectREDGeometry ( char * profileName ); 
fcns.name{fcnNum}='iV_SelectREDGeometry'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SendCommand ( char * etMessage ); 
fcns.name{fcnNum}='iV_SendCommand'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SendImageMessage ( char * etMessage ); 
fcns.name{fcnNum}='iV_SendImageMessage'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetConnectionTimeout ( int time ); 
fcns.name{fcnNum}='iV_SetConnectionTimeout'; fcns.RHS{fcnNum}={'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetEventDetectionParameter ( int minDuration , int maxDispersion ); 
fcns.name{fcnNum}='iV_SetEventDetectionParameter'; fcns.RHS{fcnNum}={'int32', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetLicense ( const char * licenseKey ); 
fcns.name{fcnNum}='iV_SetLicense'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetLogger ( int logLevel , char * filename ); 
fcns.name{fcnNum}='iV_SetLogger'; fcns.RHS{fcnNum}={'int32', 'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetREDGeometry ( struct REDGeometryStruct * redGeometry ); 
fcns.name{fcnNum}='iV_SetREDGeometry'; fcns.RHS{fcnNum}={'REDGeometryStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetResolution ( int stimulusWidth , int stimulusHeight ); 
fcns.name{fcnNum}='iV_SetResolution'; fcns.RHS{fcnNum}={'int32', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetSpeedMode ( int speedMode ); 
fcns.name{fcnNum}='iV_SetSpeedMode'; fcns.RHS{fcnNum}={'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetTrackingMode ( enum TrackingMode mode ); 
fcns.name{fcnNum}='iV_SetTrackingMode'; fcns.RHS{fcnNum}={'TrackingMode'}; if q64Bit, fcns.thunkname{fcnNum}='int32enumTrackingModeThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetTrackingParameter ( int ET_PARAM_EYE , int ET_PARAM , int value ); 
fcns.name{fcnNum}='iV_SetTrackingParameter'; fcns.RHS{fcnNum}={'int32', 'int32', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetupCalibration ( struct CalibrationStruct * calibrationData ); 
fcns.name{fcnNum}='iV_SetupCalibration'; fcns.RHS{fcnNum}={'CalibrationStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetupDebugMode ( int enableDebugMode ); 
fcns.name{fcnNum}='iV_SetupDebugMode'; fcns.RHS{fcnNum}={'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetupLptRecording ( const char * portName , int enableRecording ); 
fcns.name{fcnNum}='iV_SetupLptRecording'; fcns.RHS{fcnNum}={'cstring', 'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringint32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetUseCalibrationKeys ( int enableKeys ); 
fcns.name{fcnNum}='iV_SetUseCalibrationKeys'; fcns.RHS{fcnNum}={'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ShowAccuracyMonitor (); 
fcns.name{fcnNum}='iV_ShowAccuracyMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ShowEyeImageMonitor (); 
fcns.name{fcnNum}='iV_ShowEyeImageMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ShowSceneVideoMonitor (); 
fcns.name{fcnNum}='iV_ShowSceneVideoMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_ShowTrackingMonitor (); 
fcns.name{fcnNum}='iV_ShowTrackingMonitor'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_Start ( enum ETApplication etApplication ); 
fcns.name{fcnNum}='iV_Start'; fcns.RHS{fcnNum}={'ETApplication'}; if q64Bit, fcns.thunkname{fcnNum}='int32enumETApplicationThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_StartRecording (); 
fcns.name{fcnNum}='iV_StartRecording'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_StopRecording (); 
fcns.name{fcnNum}='iV_StopRecording'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_TestTTL ( int value ); 
fcns.name{fcnNum}='iV_TestTTL'; fcns.RHS{fcnNum}={'int32'}; if q64Bit, fcns.thunkname{fcnNum}='int32int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_Validate (); 
fcns.name{fcnNum}='iV_Validate'; fcns.RHS{fcnNum}=[]; if q64Bit, fcns.thunkname{fcnNum}='int32Thunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetupMonitorAttachedGeometry ( struct MonitorAttachedGeometryStruct * monitorAttachedGeometry ); 
fcns.name{fcnNum}='iV_SetupMonitorAttachedGeometry'; fcns.RHS{fcnNum}={'voidPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetupStandAloneMode ( struct StandAloneModeGeometryStruct * standAloneModeGeometry ); 
fcns.name{fcnNum}='iV_SetupStandAloneMode'; fcns.RHS{fcnNum}={'voidPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetupREDMonitorAttachedGeometry ( struct REDMonitorAttachedGeometryStruct * attachedModeGeometry ); 
fcns.name{fcnNum}='iV_SetupREDMonitorAttachedGeometry'; fcns.RHS{fcnNum}={'REDMonitorAttachedGeometryStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetupREDStandAloneMode ( struct REDStandAloneModeStruct * standAloneModeGeometry ); 
fcns.name{fcnNum}='iV_SetupREDStandAloneMode'; fcns.RHS{fcnNum}={'REDStandAloneModeStructPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_GetMonitorAttachedGeometry ( char profileName [ 256 ], struct MonitorAttachedGeometryStruct * monitorAttachedGeometry ); 
fcns.name{fcnNum}='iV_GetMonitorAttachedGeometry'; fcns.RHS{fcnNum}={'int8Ptr', 'voidPtr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrvoidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_SetGeometryProfile ( char * profileName ); 
fcns.name{fcnNum}='iV_SetGeometryProfile'; fcns.RHS{fcnNum}={'cstring'}; if q64Bit, fcns.thunkname{fcnNum}='int32cstringThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DeleteMonitorAttachedGeometry ( char setupName [ 256 ]); 
fcns.name{fcnNum}='iV_DeleteMonitorAttachedGeometry'; fcns.RHS{fcnNum}={'int8Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end, fcnNum=fcnNum+1;
% extern " C " int iV_DeleteStandAloneGeometry ( char setupName [ 256 ]); 
fcns.name{fcnNum}='iV_DeleteStandAloneGeometry'; fcns.RHS{fcnNum}={'int8Ptr'}; if q64Bit, fcns.thunkname{fcnNum}='int32voidPtrThunk'; end

% DEACTIVATED -> Callbacks are not possible with loadlibrary
% extern " C " int iV_SetAOIHitCallback ( pDLLSetAOIHit pAOIHitCallbackFunction ); 
% extern " C " int iV_SetCalibrationCallback ( pDLLSetCalibrationPoint pCalibrationCallbackFunction ); 
% extern " C " int iV_SetEventCallback ( pDLLSetEvent pEventCallbackFunction ); 
% extern " C " int iV_SetEyeImageCallback ( pDLLSetEyeImage pEyeImageCallbackFunction ); 
% extern " C " int iV_SetSampleCallback ( pDLLSetSample pSampleCallbackFunction ); 
% extern " C " int iV_SetSceneVideoCallback ( pDLLSetSceneVideo pSceneVideoCallbackFunction ); 
% extern " C " int iV_SetTrackingMonitorCallback ( pDLLSetTrackingMonitor pTrackingMonitorCallbackFunction ); 

% all LHS are 'int32' and all calltype are 'stdcall' for 32bit and 'Thunk'
% for 64 bit. set at once. Also set thunklibname for 64bit
[fcns.LHS{:}] = deal('int32');
if q64Bit
    [fcns.calltype{:}] = deal('Thunk');
    MfilePath=fileparts(mfilename('fullpath'));
    ThunkLibName=fullfile(MfilePath,'iViewXAPI_thunk_pcwin64');
else
    [fcns.calltype{:}] = deal('stdcall');
    ThunkLibName=[];
end


%% Data Structures
% This struct provides information about the iView eye tracking server
% version and the API version in use. To update data in SystemInfoStruct
% use the function iV_GetSystemInfo.
structs.SystemInfoStruct.members=struct('samplerate', 'int32', 'iV_MajorVersion', 'int32', 'iV_MinorVersion', 'int32', 'iV_Buildnumber', 'int32', 'API_MajorVersion', 'int32', 'API_MinorVersion', 'int32', 'API_Buildnumber', 'int32', 'iV_ETDevice', 'ETDevice');

% This struct provides information about the speed modes used and supported
% by the connected iView eye tracking server. They determine the sampling
% frequency (in Hz) of the eye tracker. To update information in
% SpeedModeStruct use function iV_GetSpeedModes.
structs.SpeedModeStruct.members=struct('version', 'int32', 'speedMode', 'int32', 'numberOfSpeedModes', 'int32', 'speedModes', 'int32#16');

% This struct provides information about the position of calibration
% points. To update information in CalibrationPointStruct during a
% calibration or validation use function iV_GetCurrentCalibrationPoint.
% Before or after the calibration use iV_GetCalibrationPoint.
% The first calibration point has the number 1, the last one has the number
% given by CalibrationStruct::method. Calibration point positions are in
% pixels.
structs.CalibrationPointStruct.members=struct('number', 'int32', 'positionX', 'int32', 'positionY', 'int32');

% This struct provides information about the fixation quality when a
% calibration point was shown. If the request calibration quality data is
% not available, the number and positionX/positionY will be set to -1. User
% have to check these fields to make sure the returned data is valid.
% The first calibration point has the number 1, the last one has the number
% given by CalibrationStruct::method. Calibration point positions and
% associated STD noise levels are in pixels.
structs.CalibrationPointQualityStruct.members=struct('number', 'int32', 'positionX', 'int32', 'positionY', 'int32', 'correctedPorX', 'double', 'correctedPorY', 'double', 'standardDeviationX', 'double', 'standardDeviationY', 'double', 'usageStatus', 'CalibrationPointUsageStatusEnum', 'qualityIndex', 'double');

% This struct provides numerical information about eye data. EyeDataStruct
% is part of SampleStruct. To update information in SampleStruct use
% function iV_GetSample. Gaze positions are in pixels, eyePositions in 3D
% space in mm.
structs.EyeDataStruct.members=struct('gazeX', 'double', 'gazeY', 'double', 'diam', 'double', 'eyePositionX', 'double', 'eyePositionY', 'double', 'eyePositionZ', 'double');

% This struct provides information about an eye data sample. To update
% information in SampleStruct use the function iV_GetSample or set the
% sample callback with iV_SetSampleCallback.
structs.SampleStruct.members=struct('timestamp', 'int64', 'leftEye', 'EyeDataStruct', 'rightEye', 'EyeDataStruct', 'planeNumber', 'int32');

% This struct provides information about a eye data samples. To update
% information in SampleStruct32 use the function iV_GetSample32. The
% difference to SampleStruct is that the timestamp will be stored in
% milliseconds instead of microseconds.
structs.SampleStruct32.members=struct('timestamp', 'double', 'leftEye', 'EyeDataStruct', 'rightEye', 'EyeDataStruct', 'planeNumber', 'int32');

% This struct provides information about the last eye event that has been
% calculated. To update information in EventStruct use function iV_GetEvent
% or set the event callback with with iV_SetEventCallback. Note, that
% fixation events are detected using an online dispersion based algorithm.
% Online event detection can be used in gaze contingent application such as
% human-computer interfaces. However, it is not intended for offline data
% analysis. Gaze positions are in pixels.
structs.EventStruct.members=struct('eventType', 'int8', 'eye', 'int8', 'startTime', 'int64', 'endTime', 'int64', 'duration', 'int64', 'positionX', 'double', 'positionY', 'double');

% This struct provides information about the last eye event that has been
% calculated. The difference to EventStruct is that the timestamp will be
% stored in milliseconds instead of microseconds and the order of the
% components are different. To update information in EventStruct32 use
% function iV_GetEvent32.
structs.EventStruct32.members=struct('startTime', 'double', 'endTime', 'double', 'duration', 'double', 'positionX', 'double', 'positionY', 'double', 'eventType', 'int8', 'eye', 'int8');

% This value represents the relative position of the eye in the tracking
% box. The 0 is defined at the center position. The value +1 defines the
% upper/right/far maximum while the value -1 the lower/left/near maximum.
% The position rating is related to the tracking monitor and represents how
% critical the tracking and the position is, related to the border of the
% tracking box. The 0 is defined as the best eye position to be tracked
% while the value +1 defines that the eye is almost not being tracked due
% to extreme upper/right/far position. The value -1 defines that the eye is
% almost not being tracked due to extreme lower/left/near position. If the
% eye is not tracked at all the validity flag goes to 0 and all values for
% the represented eye will be set to 0.
structs.EyePositionStruct.members=struct('validity', 'int32', 'relativePositionX', 'double', 'relativePositionY', 'double', 'relativePositionZ', 'double', 'positionRatingX', 'double', 'positionRatingY', 'double', 'positionRatingZ', 'double');

%  This struct provides information about the relative eye ball position
%  within the tracking box. The information will be provided for each eye
%  individually as well as for the geometric center between both eyes. To
%  update information in TrackingStatusStruct use the function
%  iV_GetTrackingStatus.
structs.TrackingStatusStruct.members=struct('timestamp', 'int64', 'leftEye', 'EyePositionStruct', 'rightEye', 'EyePositionStruct', 'total', 'EyePositionStruct');

% This struct provides information about the last validation. The provided
% deviations are the average absolute distances between meassured and
% expected gaze positions over all validation points. A validation must
% have been successfully completed before the AccuracyStruct can be
% updated. To update information in AccuracyStruct use function
% iV_GetAccuracy. Deviations are in degrees.
structs.AccuracyStruct.members=struct('deviationLX', 'double', 'deviationLY', 'double', 'deviationRX', 'double', 'deviationRY', 'double');

% This struct provides information about the last validation. A validation
% must have been successfully completed before the GazeChannelQualityStruct
% can be updated. To update information in GazeChannelQualityStruct use
% function iV_GetGazeChannelQuality. Quality index lies in the range [0,1].
% A value > 0.5 means it is acceptable. A NaN value means it is not
% provided.
structs.GazeChannelQualityStruct.members=struct('gazeChannelQualityLeft', 'double', 'gazeChannelQualityRight', 'double', 'gazeChannelQualityBinocular', 'double');

% Use this struct to customize the calibration and validation behavior. To
% set calibration parameters with CalibrationStruct use function
% iV_SetupCalibration before a calibration or validation is started.
structs.CalibrationStruct.members=struct(...
    ...% select calibration method (default: 5, options: 0,1,2,5,9,13).
    ...% Field is a bit mask that is used to specify a new calibration
    ...% workflow. bitor()-ing CALIBRATIONMETHOD_SMARTCALIBRATION
    ...% 0x80000000 (hex value) with the selected method activates the
    ...% smart calibration feature in iViewRED 4.2 or later eye tracking
    ...% server. To decode what method is used, bitand() the value in this
    ...% field with CALIBRATIONMETHOD_MASK 0x0000FFFF (hex value) to remove
    ...% the optional CALIBRATIONMETHOD_SMARTCALIBRATION flag
    'method', 'uint32',...
    ...% draw calibration/validation by API (default: 1). LEAVE TO ZERO
    ...% when using the Psychtoolbox wrapper
    'visualization', 'int32',...
    ...% set display device [0: primary device (default), 1: secondary
    ...% device]. Irrelevant when using Psychtoolbox wrapper
    'displayDevice', 'int32',...
    ...% set calibration/validation speed [0: slow (default), 1: fast]
    'speed', 'int32',...
    ...% set calibration/validation point acceptance [2: full-automatic,
    ...% 1: semi-automatic (default), 0: manual]
    'autoAccept', 'int32',...
    ...
    ...% The below are all irrelevant when using the Psychtoolbox wrapper,
    ...% as they are settings for how the calibration/validation would be
    ...% drawn by the SMI API
    ...%
    ...% set calibration/validation target brightness [0..255] (default:
    ...% 250)
    'foregroundBrightness', 'int32',...
    ...%  set calibration/validation background brightness [0..255]
    ...% (default: 220)
    'backgroundBrightness', 'int32',...
    ...% set calibration/validation target shape [IMAGE = 0, CIRCLE1 = 1,
    ...% CIRCLE2 = 2 (default), CROSS = 3]
    'targetShape', 'int32',...
    ...% set calibration/validation target size in pixel (minimum: 10
    ...% pixels, default: 20 pixels)
    'targetSize', 'int32',...
    ...% select custom calibration/validation target (only if
    ...% targetShape = 0)
    'targetFilename', 'int8#256');

% Use this struct to customize the RED geometry. See chapter about RED
% geometry in the iView X SDK Manual for details. For setting up the RED
% geometry parameters with REDGeometryStruct use function
% iV_SetREDGeometry.
structs.REDGeometryStruct.members=struct('redGeometry', 'REDGeometryEnum', 'monitorSize', 'int32', 'setupName', 'int8#256', 'stimX', 'int32', 'stimY', 'int32', 'stimHeightOverFloor', 'int32', 'redHeightOverFloor', 'int32', 'redStimDist', 'int32', 'redInclAngle', 'int32', 'redStimDistHeight', 'int32', 'redStimDistDepth', 'int32');

% Use this struct to get raw eye image, raw scene video image, raw tracking monitor image or accuracy image: 
% - For receiving raw eye image (format: monochrome 8bpp) use
%   iV_GetEyeImage.
% - For receiving raw scene video image (format: RGB 24bpp) use
%   iV_GetSceneVideo.
% - For receiving raw tracking monitor image (format: BGR 24bpp) use
%   iV_GetTrackingMonitor.
% - For receiving the accuracy image (format: BGR 24bpp) use
%   iV_GetAccuracyImage.
% - For receiving the calibration quality image (format: BGR 24bpp) use
%   iV_GetCalibrationQualityImage.
structs.ImageStruct.members=struct('imageHeight', 'int32', 'imageWidth', 'int32', 'imageSize', 'int32', 'imageBuffer', 'uint8Ptr');

% Use this struct to get the license due date of the device. Use the
% function iV_GetLicenseDueDate to update information in DateStruct.
structs.DateStruct.members=struct('day', 'int32', 'month', 'int32', 'year', 'int32');

% Use this struct to customize the AOI position on screen.
% AOIRectangleStruct is a part of AOIStruct and can be defined with
% iV_DefineAOI.
structs.AOIRectangleStruct.members=struct('x1', 'int32', 'x2', 'int32', 'y1', 'int32', 'y2', 'int32');

% Use this struct to customize trigger AOIs. To define AOIs on screen,
% trigger parameter and trigger values use iV_DefineAOIPort and
% iV_DefineAOI functions.
structs.AOIStruct.members=struct('enabled', 'int32', 'aoiName', 'int8#256', 'aoiGroup', 'int8#256', 'position', 'AOIRectangleStruct', 'fixationHit', 'int32', 'outputValue', 'int32', 'outputMessage', 'int8#256', 'eye', 'int8');

% Deprecated. Please use REDGeometryStruct instead.
structs.REDStandAloneModeStruct.members=struct('stimX', 'int32', 'stimY', 'int32', 'stimHeightOverFloor', 'int32', 'redHeightOverFloor', 'int32', 'redStimDist', 'int32', 'redInclAngle', 'int32');

% Deprecated. Please use REDGeometryStruct instead.
structs.REDMonitorAttachedGeometryStruct.members=struct('stimX', 'int32', 'stimY', 'int32', 'redStimDistHeight', 'int32', 'redStimDistDepth', 'int32', 'redInclAngle', 'int32');


%% Enumerations
% This enum provides information about whether a calibration point was
% actually used for the calibration or the reason why it was not used. Use
% iV_GetCalibrationQuality to retrieve the calibration quality data
enuminfo.CalibrationPointUsageStatusEnum=struct(...
    ...% the calibration point was accepted and is used for the calibration
    'calibrationPointUsed',0,...
    ...% the calibration point was rejected and is not used for the calibration
    'calibrationPointUnused',1,...
    ...% the calibration point was rejected because no fixation was detected within reasonable time
    'calibrationPointUnusedBecauseOfTimeout',2,...
    ...% the calibration point was rejected because the detected fixation was too imprecise
    'calibrationPointUnusedBecauseOfBadQuality',3,...
    ...% no fixation was detected for the calibration point, but it is also not required
    'calibrationPointIgnored',4);

% The enumeration ETDevice can be used in connection with iV_GetSystemInfo
% to get information about which type of device is connected to iView X or
% iView eye tracking server. It is part of the SystemInfoStruct.
enuminfo.ETDevice=struct(...
    ...% if no device is set up while running iView X application
    'NONE',0,...
    ...% iView X based remote eye tracking devices
    'RED',1,...
    ...% eye tracking server or iViewNG based remote eye tracking devices
    'REDm',2,...
    ...% iView X based hi speed eye tracking devices
    'HiSpeed',3,...
    ...% iView X based MRI eye tracking devices
    'MRI',4,...
    ...% iView X based head mounted eye tracking devices
    'HED',5,...
    ...% iView X based custom devices like the mouse grabber
    'Custom',7,...
    ...% iViewRED based REDn eye tracking devices
    'REDn',8);

% FilterAction can be used to select the action that is performed when
% calling iV_ConfigureFilter
enuminfo.FilterAction=struct(...
    ...% query the current filter status
    'Query',0,...
    ...% configure filter parameters
    'Set',1);

% ETApplication can be used to start iView X, iView X OEM or iViewNGServer
% (iView eye tracking server) application dependent to the used eye
% tracking device. Set this as a parameter in iV_Start function.
enuminfo.ETApplication=struct(...
    ...% for iView X based devices like RED, HiSpeed, MRI, HED
    'iViewX',0,...
    ...% for RED-OEM based devices like RED-m or other customized RED-OEM devices
    'iViewXOEM',1,...
    ...% for RED250mobile and REDn devices
    'iViewNG',2);

% FilterType can be used to select the action that is performed when
% calling iV_ConfigureFilter
enuminfo.FilterType=struct(...
    ...% Left and right gaze data channels are averaged.
	...% Both @ref EyeDataStruct in a @ref SampleStruct, e.g. obtained by @ref iV_GetSample, 
	...% contain equal gaze position data if the filter is anabled.
	...% Also data within recorded files is affected.
	...% The type of the parameter data from @ref iV_ConfigureFilter has to be converted to int*.
	...% The value of data can be [0;1] where 0 means averaging is disabled and 1 means averaging is enabled.
    'Average',0);

% Is used to select the valid data fields of REDGeometryStruct
enuminfo.REDGeometryEnum=struct(...
    ...% use monitor integrated mode
    'monitorIntegrated',0,...
    ...% use standalone mode
    'standalone',1);

% This enum provides information about the iView eye tracking server
% calibration status. If the device is not calibrated the iView eye
% tracking server will not deliver valid gaze data. Use the functions
% iV_GetCalibrationStatus to retrieve the calibration status and
% iV_Calibrate to perform a calibration.
enuminfo.CalibrationStatusEnum=struct(...
    ...% calibration status is unknown (i.e. if the connection is not established)
    'calibrationUnknown',0,...
    ...% the device is not calibrated and will not deliver valid gaze data
    'calibrationInvalid',1,...
    ...% the device is calibrated and will deliver valid gaze data
    'calibrationValid',2,...
    ...% the device is currently performing a calibration
    'calibrationInProgress',3);

% Defines the recording states reported by the eye tracking server
enuminfo.RecordingState=struct(...
    ...% Recording state is idle. A recording was not started, no data has been collected.
    'RecordingIdle',0,...
    ...% Recording in progress. A recording was started and data is currently collected.
    'RecordingRunning',1,...
    ...% Recording is stopped. A recording is active, but currently stopped and no data is currently collected. In this state the recording can either be finished or continued.
    'RecordingStopped',2);

% will be used for set and query of the tracking mode using
% iV_SetTrackingMode and iV_GetTrackingMode. See TrackingMode, the
% trackerParameter subsection and the SMI iView eye tracking server manual
% for further explanations.
enuminfo.TrackingMode=struct(...
    ...% SmartBinocular mode
    'SmartBinocular',0,...
    ...% Monocular mode using only the left eye
    'MonocularLeft',1,...
    ...% Monocular mode using only the right eye
    'MonocularRight',2,...
    ...% Binocular mode
    'Binocular',3,...
    ...% SmartMonocular mode
    'SmartMonocular',4);